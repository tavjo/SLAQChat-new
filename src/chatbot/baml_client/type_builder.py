###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml-py
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# ruff: noqa: E501,F401
# flake8: noqa: E501,F401
# pylint: disable=unused-import,line-too-long
# fmt: off
import typing
from baml_py.baml_py import FieldType, EnumValueBuilder, EnumBuilder, ClassBuilder
from baml_py.type_builder import TypeBuilder as _TypeBuilder, ClassPropertyBuilder, ClassPropertyViewer, EnumValueViewer
from .globals import DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME


class TypeBuilder(_TypeBuilder):
    def __init__(self):
        super().__init__(classes=set(
          ["Agent","ChatResponse","Column","DBSchema","DataSummarizer","Messages","Metadata","Navigator","ParsedQuery","Payload","QueryParser","ResourceBox","Responder","ResponseFormatter","SampleTypeAttributes","SchemaMapper","Supervisor","Table","ToolArgs","ToolMetadata","UpdatePipelineMetadata","Validator",]
        ), enums=set(
          []
        ), runtime=DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME)


    @property
    def Agent(self) -> "AgentAst":
        return AgentAst(self)

    @property
    def ChatResponse(self) -> "ChatResponseAst":
        return ChatResponseAst(self)

    @property
    def Column(self) -> "ColumnAst":
        return ColumnAst(self)

    @property
    def DBSchema(self) -> "DBSchemaAst":
        return DBSchemaAst(self)

    @property
    def DataSummarizer(self) -> "DataSummarizerAst":
        return DataSummarizerAst(self)

    @property
    def Messages(self) -> "MessagesAst":
        return MessagesAst(self)

    
    @property
    def Metadata(self) -> "MetadataBuilder":
        return MetadataBuilder(self)

    @property
    def Navigator(self) -> "NavigatorAst":
        return NavigatorAst(self)

    @property
    def ParsedQuery(self) -> "ParsedQueryAst":
        return ParsedQueryAst(self)

    @property
    def Payload(self) -> "PayloadAst":
        return PayloadAst(self)

    @property
    def QueryParser(self) -> "QueryParserAst":
        return QueryParserAst(self)

    @property
    def ResourceBox(self) -> "ResourceBoxAst":
        return ResourceBoxAst(self)

    @property
    def Responder(self) -> "ResponderAst":
        return ResponderAst(self)

    @property
    def ResponseFormatter(self) -> "ResponseFormatterAst":
        return ResponseFormatterAst(self)

    @property
    def SampleTypeAttributes(self) -> "SampleTypeAttributesAst":
        return SampleTypeAttributesAst(self)

    @property
    def SchemaMapper(self) -> "SchemaMapperAst":
        return SchemaMapperAst(self)

    @property
    def Supervisor(self) -> "SupervisorAst":
        return SupervisorAst(self)

    @property
    def Table(self) -> "TableAst":
        return TableAst(self)

    @property
    def ToolArgs(self) -> "ToolArgsAst":
        return ToolArgsAst(self)

    @property
    def ToolMetadata(self) -> "ToolMetadataAst":
        return ToolMetadataAst(self)

    @property
    def UpdatePipelineMetadata(self) -> "UpdatePipelineMetadataAst":
        return UpdatePipelineMetadataAst(self)

    @property
    def Validator(self) -> "ValidatorAst":
        return ValidatorAst(self)





class AgentAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Agent")
        self._properties: typing.Set[str] = set([ "agent",  "role",  "toolbox", ])
        self._props = AgentProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "AgentProperties":
        return self._props


class AgentViewer(AgentAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class AgentProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def agent(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("agent"))

    @property
    def role(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("role"))

    @property
    def toolbox(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("toolbox"))

    

class ChatResponseAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ChatResponse")
        self._properties: typing.Set[str] = set([ "name",  "retrieve_info",  "response",  "user_query",  "justification", ])
        self._props = ChatResponseProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ChatResponseProperties":
        return self._props


class ChatResponseViewer(ChatResponseAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ChatResponseProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def retrieve_info(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("retrieve_info"))

    @property
    def response(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("response"))

    @property
    def user_query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("user_query"))

    @property
    def justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("justification"))

    

class ColumnAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Column")
        self._properties: typing.Set[str] = set([ "name",  "type",  "nullable",  "default",  "json_keys", ])
        self._props = ColumnProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ColumnProperties":
        return self._props


class ColumnViewer(ColumnAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ColumnProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("type"))

    @property
    def nullable(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("nullable"))

    @property
    def default(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("default"))

    @property
    def json_keys(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("json_keys"))

    

class DBSchemaAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DBSchema")
        self._properties: typing.Set[str] = set([ "tables", ])
        self._props = DBSchemaProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DBSchemaProperties":
        return self._props


class DBSchemaViewer(DBSchemaAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DBSchemaProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def tables(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tables"))

    

class DataSummarizerAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("DataSummarizer")
        self._properties: typing.Set[str] = set([ "summary",  "explanation",  "justification", ])
        self._props = DataSummarizerProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "DataSummarizerProperties":
        return self._props


class DataSummarizerViewer(DataSummarizerAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class DataSummarizerProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def summary(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("summary"))

    @property
    def explanation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("explanation"))

    @property
    def justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("justification"))

    

class MessagesAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Messages")
        self._properties: typing.Set[str] = set([ "name",  "message",  "role", ])
        self._props = MessagesProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MessagesProperties":
        return self._props


class MessagesViewer(MessagesAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class MessagesProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def message(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("message"))

    @property
    def role(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("role"))

    

class MetadataAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Metadata")
        self._properties: typing.Set[str] = set([ "Link_PrimaryData",  "Name",  "UID", ])
        self._props = MetadataProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "MetadataProperties":
        return self._props


class MetadataBuilder(MetadataAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    def add_property(self, name: str, type: FieldType) -> ClassPropertyBuilder:
        if name in self._properties:
            raise ValueError(f"Property {name} already exists.")
        return ClassPropertyBuilder(self._bldr.property(name).type(type))

    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyBuilder]]:
        return [(name, ClassPropertyBuilder(self._bldr.property(name))) for name in self._properties]



class MetadataProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def Link_PrimaryData(self) -> ClassPropertyBuilder:
        return ClassPropertyBuilder(self.__bldr.property("Link_PrimaryData"))

    @property
    def Name(self) -> ClassPropertyBuilder:
        return ClassPropertyBuilder(self.__bldr.property("Name"))

    @property
    def UID(self) -> ClassPropertyBuilder:
        return ClassPropertyBuilder(self.__bldr.property("UID"))

    
    def __getattr__(self, name: str) -> ClassPropertyBuilder:
        if name not in self.__properties:
            raise AttributeError(f"Property {name} not found.")
        return ClassPropertyBuilder(self.__bldr.property(name))
    

class NavigatorAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Navigator")
        self._properties: typing.Set[str] = set([ "agent",  "explanation",  "next_tool",  "tool_args",  "justification", ])
        self._props = NavigatorProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "NavigatorProperties":
        return self._props


class NavigatorViewer(NavigatorAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class NavigatorProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def agent(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("agent"))

    @property
    def explanation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("explanation"))

    @property
    def next_tool(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("next_tool"))

    @property
    def tool_args(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("tool_args"))

    @property
    def justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("justification"))

    

class ParsedQueryAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ParsedQuery")
        self._properties: typing.Set[str] = set([ "uid",  "sampletype",  "assay",  "attribute",  "terms", ])
        self._props = ParsedQueryProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ParsedQueryProperties":
        return self._props


class ParsedQueryViewer(ParsedQueryAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ParsedQueryProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def uid(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("uid"))

    @property
    def sampletype(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("sampletype"))

    @property
    def assay(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("assay"))

    @property
    def attribute(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attribute"))

    @property
    def terms(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("terms"))

    

class PayloadAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Payload")
        self._properties: typing.Set[str] = set([ "user_query",  "aggregatedMessages",  "resource",  "last_worker", ])
        self._props = PayloadProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "PayloadProperties":
        return self._props


class PayloadViewer(PayloadAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class PayloadProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def user_query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("user_query"))

    @property
    def aggregatedMessages(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("aggregatedMessages"))

    @property
    def resource(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("resource"))

    @property
    def last_worker(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("last_worker"))

    

class QueryParserAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("QueryParser")
        self._properties: typing.Set[str] = set([ "parsed_query",  "explanation",  "justification", ])
        self._props = QueryParserProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "QueryParserProperties":
        return self._props


class QueryParserViewer(QueryParserAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class QueryParserProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def parsed_query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("parsed_query"))

    @property
    def explanation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("explanation"))

    @property
    def justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("justification"))

    

class ResourceBoxAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResourceBox")
        self._properties: typing.Set[str] = set([ "sample_metadata",  "protocolURL",  "sampleURL",  "UIDs",  "db_schema",  "parsed_query",  "st_attributes",  "update_info", ])
        self._props = ResourceBoxProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResourceBoxProperties":
        return self._props


class ResourceBoxViewer(ResourceBoxAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResourceBoxProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def sample_metadata(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("sample_metadata"))

    @property
    def protocolURL(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("protocolURL"))

    @property
    def sampleURL(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("sampleURL"))

    @property
    def UIDs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("UIDs"))

    @property
    def db_schema(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("db_schema"))

    @property
    def parsed_query(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("parsed_query"))

    @property
    def st_attributes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("st_attributes"))

    @property
    def update_info(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("update_info"))

    

class ResponderAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Responder")
        self._properties: typing.Set[str] = set([ "Next_worker",  "explanation",  "justification", ])
        self._props = ResponderProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResponderProperties":
        return self._props


class ResponderViewer(ResponderAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResponderProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def Next_worker(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("Next_worker"))

    @property
    def explanation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("explanation"))

    @property
    def justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("justification"))

    

class ResponseFormatterAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ResponseFormatter")
        self._properties: typing.Set[str] = set([ "formattedResponse",  "name",  "explanation",  "justification", ])
        self._props = ResponseFormatterProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ResponseFormatterProperties":
        return self._props


class ResponseFormatterViewer(ResponseFormatterAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ResponseFormatterProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def formattedResponse(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("formattedResponse"))

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def explanation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("explanation"))

    @property
    def justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("justification"))

    

class SampleTypeAttributesAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SampleTypeAttributes")
        self._properties: typing.Set[str] = set([ "sampletype",  "st_description",  "attributes", ])
        self._props = SampleTypeAttributesProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SampleTypeAttributesProperties":
        return self._props


class SampleTypeAttributesViewer(SampleTypeAttributesAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SampleTypeAttributesProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def sampletype(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("sampletype"))

    @property
    def st_description(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("st_description"))

    @property
    def attributes(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("attributes"))

    

class SchemaMapperAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("SchemaMapper")
        self._properties: typing.Set[str] = set([ "name",  "relevant_keys",  "schema_map",  "justification",  "explanation", ])
        self._props = SchemaMapperProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SchemaMapperProperties":
        return self._props


class SchemaMapperViewer(SchemaMapperAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SchemaMapperProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def relevant_keys(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("relevant_keys"))

    @property
    def schema_map(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("schema_map"))

    @property
    def justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("justification"))

    @property
    def explanation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("explanation"))

    

class SupervisorAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Supervisor")
        self._properties: typing.Set[str] = set([ "Next_worker",  "explanation",  "justification", ])
        self._props = SupervisorProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "SupervisorProperties":
        return self._props


class SupervisorViewer(SupervisorAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class SupervisorProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def Next_worker(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("Next_worker"))

    @property
    def explanation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("explanation"))

    @property
    def justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("justification"))

    

class TableAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Table")
        self._properties: typing.Set[str] = set([ "name",  "columns", ])
        self._props = TableProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "TableProperties":
        return self._props


class TableViewer(TableAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class TableProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def columns(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("columns"))

    

class ToolArgsAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ToolArgs")
        self._properties: typing.Set[str] = set([ "json_keys",  "terms",  "uid",  "sample_type", ])
        self._props = ToolArgsProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ToolArgsProperties":
        return self._props


class ToolArgsViewer(ToolArgsAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ToolArgsProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def json_keys(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("json_keys"))

    @property
    def terms(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("terms"))

    @property
    def uid(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("uid"))

    @property
    def sample_type(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("sample_type"))

    

class ToolMetadataAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("ToolMetadata")
        self._properties: typing.Set[str] = set([ "doc",  "signature", ])
        self._props = ToolMetadataProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ToolMetadataProperties":
        return self._props


class ToolMetadataViewer(ToolMetadataAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ToolMetadataProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def doc(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("doc"))

    @property
    def signature(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("signature"))

    

class UpdatePipelineMetadataAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("UpdatePipelineMetadata")
        self._properties: typing.Set[str] = set([ "success",  "logs",  "errors",  "stats", ])
        self._props = UpdatePipelineMetadataProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "UpdatePipelineMetadataProperties":
        return self._props


class UpdatePipelineMetadataViewer(UpdatePipelineMetadataAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class UpdatePipelineMetadataProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def success(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("success"))

    @property
    def logs(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("logs"))

    @property
    def errors(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("errors"))

    @property
    def stats(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("stats"))

    

class ValidatorAst:
    def __init__(self, tb: _TypeBuilder):
        _tb = tb._tb # type: ignore (we know how to use this private attribute)
        self._bldr = _tb.class_("Validator")
        self._properties: typing.Set[str] = set([ "name",  "explanation",  "Valid",  "response",  "error",  "Clarifying_Question",  "justification", ])
        self._props = ValidatorProperties(self._bldr, self._properties)

    def type(self) -> FieldType:
        return self._bldr.field()

    @property
    def props(self) -> "ValidatorProperties":
        return self._props


class ValidatorViewer(ValidatorAst):
    def __init__(self, tb: _TypeBuilder):
        super().__init__(tb)

    
    def list_properties(self) -> typing.List[typing.Tuple[str, ClassPropertyViewer]]:
        return [(name, ClassPropertyViewer(self._bldr.property(name))) for name in self._properties]



class ValidatorProperties:
    def __init__(self, bldr: ClassBuilder, properties: typing.Set[str]):
        self.__bldr = bldr
        self.__properties = properties

    

    @property
    def name(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("name"))

    @property
    def explanation(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("explanation"))

    @property
    def Valid(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("Valid"))

    @property
    def response(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("response"))

    @property
    def error(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("error"))

    @property
    def Clarifying_Question(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("Clarifying_Question"))

    @property
    def justification(self) -> ClassPropertyViewer:
        return ClassPropertyViewer(self.__bldr.property("justification"))

    




__all__ = ["TypeBuilder"]